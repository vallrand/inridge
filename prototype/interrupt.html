<!doctype html>
<html>
<head>
    <meta charset='UTF-8'/>
    <meta name='mobile-web-app-capable' content='yes'>
    <meta name='viewport' content='width=device-width,height=device-height,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no'/>
    <style>
        body{
            margin: 0;
            background: #181a1c;
            color: #ffffff;
            user-select: none;
        }
        canvas{
            max-width: 100%;
            max-height: 100%;
            display: block;
            margin: auto;
        }
        i{color:#95bac7;}
        b{color:#fcba03;}
        label{padding:0em 1em;}
        input[type="number"]{color:#a0ffff;background:#020208;padding:0em 0.5em;}
    </style>
</head>
<body>
    <!--<div><label>A</label><input type="checkbox" onchange="check('A', event.target.checked)"/></div>
    <div><label>B</label><input type="checkbox" onchange="check('B', event.target.checked)"/></div>
    <div><label>C</label><input type="checkbox" onchange="check('C', event.target.checked)"/></div>-->
    <div><button onclick="trigger('A')">A</button></div>
    <div><button onclick="trigger('B')">B</button></div>
    <div><button onclick="trigger('C')">C</button></div>
    <div><button onclick="trigger('D')">D</button></div>
    <div id="log"></div>
<script>
    const canvas = document.createElement('canvas')
    const ctx = canvas.getContext('2d')
    Object.assign(canvas, { width: 600, height: 400 })
    document.body.appendChild(canvas)

    class StateMachine {
        constructor(descriptor){
            this.elapsed = 0
            this.descriptor = descriptor
            this.current_state = Object.keys(descriptor.states)[0]
            this.after = []
            this.stack = []
        }
        get_current_state(){
            if(this.stack.length) return this.stack[0].ref.to
            else return this.current_state
        }
        rebalance_weight(transition, total_weight, target_weight){
            transition._weight = target_weight
            // transition._rem_weight = total_weight - target_weight
            transition._normalized = target_weight / total_weight
            const elapsed = transition._normalized * transition.ref.duration
            transition.start_time = this.elapsed - elapsed
            return transition
        }
        update(delta_time){
            this.elapsed += delta_time

            let total_weight = 1
            for(let i = 0; i < this.stack.length; i++){
                let transition = this.stack[i]

                // if(i == 0){
                    const elapsed = this.elapsed - transition.start_time
                    transition._normalized = elapsed / transition.ref.duration
                // }
                transition._weight = total_weight * transition._normalized
                total_weight -= transition._weight
                // transition._rem_weight = total_weight

                if(transition._normalized >= 1){
                    this.current_state = transition.ref.to
                    this.stack.length = i
                    break
                }
            }

            let current_state = this.get_current_state()
            let next_transition = -1
            for(let i = 0; i < this.descriptor.transitions.length; i++){
                let transition = this.descriptor.transitions[i]

                if(this.stack.length && this.stack[0].ref === transition) continue

                if(current_state === transition.from && transition.when(this.descriptor.params)){
                    next_transition = i
                    break
                }
            }
            if(next_transition != -1){
                const transition = this.descriptor.transitions[next_transition]
                const target_weight = this.calc_weight(transition.to)
                console.log(`transition ${transition.from} ${transition.to} (${target_weight})`)

                shift:{
                    let next = { ref: transition }
                    for(let i = 0; i < this.stack.length; i++){
                        let swap = this.stack[i]
                        this.stack[i] = next
                        next = swap
                        if(next.ref.to === transition.to){
                            break shift
                        }
                    }
                    if(this.current_state === transition.to){
                        this.current_state = next.ref.to
                    }else{
                        this.stack.push(next)
                    }
                }
                rebalance:{
                    this.stack[0]._weight = target_weight
                    let total_weight = 1
                    for(let i = 0; i < this.stack.length; i++){
                        this.rebalance_weight(this.stack[i], total_weight, this.stack[i]._weight)
                        total_weight = total_weight - this.stack[i]._weight
                    }
                }

                // let total_weight = 1
                // let next = this.stack.push({ ref: transition, _weight: target_weight }) - 1
                // for(let i = 0; i < this.stack.length; i++){
                //     if(this.stack[next].ref.to === transition.to && i != 0){

                //     }else{
                //         let swap = this.stack[i]
                //         this.stack[i] = this.stack[next]
                //         this.stack[next] = swap
                //     }

                //     this.rebalance_weight(this.stack[i], total_weight, this.stack[i]._weight)
                //     total_weight = total_weight - this.stack[i]._weight
                // }



                // this.stack.unshift(this.rebalance_weight({
                //     ref: transition
                // }, 1.0, target_weight))

                // let total_weight = 1.0 - this.stack[0]._weight
                // for(let i = 1; i < this.stack.length; i++){
                //     // let total_weight = this.stack[i - 1]._rem_weight
                //     let target_weight = this.stack[i]._weight
                //     if(this.stack[i].ref.to === transition.to){
                //         this.stack.splice(i, 1)
                //         i--
                //         continue
                //     }
                //     this.rebalance_weight(this.stack[i], total_weight, target_weight)
                //     total_weight = total_weight - this.stack[i]._weight
                // }
                // if(this.current_state === transition.to){
                //     this.current_state = this.stack[this.stack.length - 1].ref.to
                //     this.stack.length--
                // }
                //break
            }
            while(this.after.length) this.after.pop()()
        }
        calc_weight(key){
            let total_weight = 1
            for(let i = 0; i < this.stack.length; i++){
                let weight = total_weight * this.stack[i]._normalized
                total_weight -= weight
                if(this.stack[i].ref.to === key) return weight
            }
            if(this.current_state === key) return total_weight
            return 0
        }
    }

    const state_manager = new StateMachine({
        states: {
            'A': {},
            'B': {},
            'C': {},
            'D': {}
        },
        transitions: [
            {from:'A',to:'B', duration: 2, when: params => params.B === true },
            {from:'A',to:'C', duration: 2, when: params => params.C === true },
            {from:'B',to:'A', duration: 2, when: params => params.A === true },
            {from:'B',to:'C', duration: 2, when: params => params.C === true },
            {from:'C',to:'B', duration: 2, when: params => params.B === true },
            {from:'C',to:'A', duration: 2, when: params => params.A === true },

            {from:'A',to:'D', duration: 2, when: params => params.D === true },
            {from:'B',to:'D', duration: 2, when: params => params.D === true },
            {from:'C',to:'D', duration: 2, when: params => params.D === true },
            {from:'D',to:'A', duration: 2, when: params => params.A === true },
            {from:'D',to:'B', duration: 2, when: params => params.B === true },
            {from:'D',to:'C', duration: 2, when: params => params.C === true },
        ],
        params: {}
    })
    function check(key, toggle){
        console.log(key, toggle)
        state_manager.descriptor.params[key] = toggle
    }
    function trigger(key){
        state_manager.descriptor.params[key] = true
        state_manager.after.push(() => state_manager.descriptor.params[key] = false)
    }
    addEventListener('keydown', event => {
        // console.log(event.key)
        if(event.key === ' '){
            speed.push(speed.shift())
        }else
        trigger(event.key.toUpperCase())
    })

    function draw_circle(x, y, r, color){
        ctx.beginPath()
        ctx.arc(x, y, r, 0, 2 * Math.PI, false)
        ctx.fillStyle = color
        ctx.fill()
    }
    const states = {
        'A': { position: { x: 50, y: 50 } },
        'B': { position: { x: 300, y: 100 } },
        'C': { position: { x: 150, y: 250 } },
        'D': { position: { x: 350, y: 200 } },
    }
    const trail = []
    let speed = [0.02,0.002,0]

    requestAnimationFrame(function update(){
        ctx.resetTransform()
        ctx.clearRect(0, 0, canvas.width, canvas.height)

        state_manager.update(speed[0])
        for(let key in states)
            draw_circle(states[key].position.x, states[key].position.y, 16, '#ff6622')

        let x = 0, y = 0
        for(let key in states){
            let weight = state_manager.calc_weight(key)
            x += weight * states[key].position.x
            y += weight * states[key].position.y
        }
        draw_circle(x, y, 8, '#11aaff')
        trail.push([x,y])
        if(trail.length > 64) trail.shift()

        ctx.beginPath()
        ctx.moveTo(x, y)
        for(let i = trail.length - 1; i >= 0; i--)
            ctx.lineTo(trail[i][0], trail[i][1])
        ctx.lineWidth = 2
        ctx.strokeStyle = '#11aaff'
        ctx.stroke()

        document.getElementById('log').innerHTML = (`
        stack: [${state_manager.stack.map(transition => `${transition.ref.from}->${transition.ref.to}`).join(' ')}]<br>
        current: ${state_manager.get_current_state()}
        `)

        requestAnimationFrame(update)
    })
</script>
</body>
</html>