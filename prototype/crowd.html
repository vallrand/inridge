<!doctype html>
<html>
<head>
    <meta charset='UTF-8'/>
    <meta name='mobile-web-app-capable' content='yes'>
    <meta name='viewport' content='width=device-width,height=device-height,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no'/>
    <style>
        body{
            margin: 0;
            background: #181a1c;
            color: #ffffff;
            user-select: none;
        }
        canvas{
            max-width: 100%;
            max-height: 100%;
            display: block;
            margin: auto;
        }
        i{color:#95bac7;}
        b{color:#fcba03;}
        label{padding:0em 1em;}
        input[type="number"]{color:#a0ffff;background:#020208;padding:0em 0.5em;}
    </style>
</head>
<body>
<script src="lib.js"></script>
<script>
    const app = new Application()
    .register(Renderer, { width: 800, height: 600 })
    .register(Camera, { x: 0, y: 0 })
    .register(Pointer)
    .register(Keyboard)
    .register(class CameraController {
        update(context){
            const camera = context.fetch(Camera)
            const pointer = context.fetch(Pointer)
            const keys = context.fetch(Keyboard)

            // if(pointer.pressed && pointer.trigger) this.start = {
            //     x: camera.x - pointer.position.x,
            //     y: camera.y - pointer.position.y
            // }
            // if(pointer.pressed){
            //     camera.x = this.start.x + pointer.position.x
            //     camera.y = this.start.y + pointer.position.y
            // }
        }
    })
    .register(class Demo {
        constructor(context){
            this.show_jagged_path = true
            this.spawners = [{ elapsed: 0, rate: 0.1, x: 0, y: 0, path: [
                { x: 0, y: 0 },
                { x: 100, y: -100 },
                { x: 200, y: 0 },
                { x: 100, y: 100 },
                { x: 200, y: 200 },
            ] }]
            this.units = []
        }
        start(context){}
        find_random_empty_spot(x, y){
            let deviation = 10
            x += deviation * (Math.random() * 2.0 - 1.0)
            y += deviation * (Math.random() * 2.0 - 1.0)
            resolve_collisions: {
                let acc_x = 0
                let acc_y = 0
                let total = 0

                const radius = 5
                for(let unit of this.units){
                    let target_x = unit.formation.target.x
                    let target_y = unit.formation.target.y
                    let distance = Math.hypot(x - target_x, y - target_y)
                    if(distance < radius + radius){
                        let delta = radius + radius - distance
                        let delta_x = delta * (x - target_x) / distance
                        let delta_y = delta * (y - target_y) / distance
                        acc_x += delta_x
                        acc_y += delta_y
                        total++
                    }
                }
                x += acc_x// / total
                y += acc_y// / total
            }
            return { x, y }
        }
        update(context){
            for(let spawner of this.spawners){
                spawner.elapsed += context.deltaTime * 1e-3
                if(spawner.elapsed > spawner.rate){
                    spawner.elapsed = 0
                    this.units.push({
                        formation: {
                            origin: { ...spawner.path[0] },
                            target: { ...spawner.path[0] },
                            elapsed: 1, x: spawner.path[0].x, y: spawner.path[0].y
                        },
                        movement: { elapsed: 0, velocity: 2, path: spawner.path }
                    })
                }
            }
            for(let i = this.units.length - 1; i >= 0; i--){
                let unit = this.units[i]
                unit.movement.elapsed += context.deltaTime * 1e-3
                //find fraction in path
                let step = (unit.movement.elapsed / unit.movement.velocity) | 0
                let substep = (unit.movement.elapsed % unit.movement.velocity) / unit.movement.velocity

                if(step + 1 >= unit.movement.path.length){
                    this.units.splice(i, 1)
                    continue
                }

                let prev = unit.movement.path[step]
                let next = unit.movement.path[step + 1]

                let interpolated_x = prev.x + substep * (next.x - prev.x)
                let interpolated_y = prev.y + substep * (next.y - prev.y)

                formation: {
                    const sub_velocity = 0.2
                    unit.formation.elapsed = Math.min(1, unit.formation.elapsed + context.deltaTime * 1e-3 / sub_velocity)
                    if(unit.formation.elapsed < 1) break formation
                    const distance = Math.hypot(interpolated_x - unit.formation.target.x, interpolated_y - unit.formation.target.y)
                    const jump_distance = 30
                    if(distance > jump_distance){
                        const random_empty_spot = this.find_random_empty_spot(interpolated_x, interpolated_y)
                        unit.formation.origin.x = unit.formation.target.x
                        unit.formation.origin.y = unit.formation.target.y
                        unit.formation.target = random_empty_spot
                        unit.formation.elapsed = 0
                    }
                }
                if(this.show_jagged_path){
                    let fraction = unit.formation.elapsed
                    unit.formation.x = unit.formation.origin.x + fraction * (unit.formation.target.x - unit.formation.origin.x)
                    unit.formation.y = unit.formation.origin.y + fraction * (unit.formation.target.y - unit.formation.origin.y)
                }else{
                    unit.formation.x = interpolated_x
                    unit.formation.y = interpolated_y
                }
            }

            const renderer = context.fetch(Renderer)
            const camera = context.fetch(Camera)
            this.render(renderer.ctx)
        }
        render(ctx){
            for(let { x, y, path } of this.spawners){
                ctx.save()
                ctx.translate(x, y)

                ctx.fillStyle = 'rgba(255,200,200,1.0)'
                ctx.beginPath()
                ctx.arc(0, 0, 10, 0, 2 * Math.PI, false)
                ctx.closePath()
                ctx.fill()

                ctx.strokeStyle = 'rgba(255,0,0,1.0)'
                ctx.lineWidth = 1
                ctx.moveTo(0, 0)
                for(let point of path)
                    ctx.lineTo(point.x - x, point.y - y)
                ctx.stroke()

                ctx.restore()
            }
            ctx.fillStyle = 'rgba(150,200,100,1.0)'
            ctx.strokeStyle = 'rgba(200,250,200,1.0)'
            ctx.lineWidth = 2
            for(const { formation: { x, y } } of this.units){
                ctx.beginPath()
                ctx.arc(x, y, 5, 0, 2 * Math.PI, false)
                ctx.closePath()
                ctx.fill()
                ctx.stroke()
            }
        }
    })
    .run()
</script>
</body>
</html>