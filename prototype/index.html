<!doctype html>
<html>
<head>
    <meta charset='UTF-8'/>
    <meta name='mobile-web-app-capable' content='yes'>
    <meta name='viewport' content='width=device-width,height=device-height,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no'/>
    <style>
        body{
            margin: 0;
            background: #181a1c;
            color: #ffffff;
            user-select: none;
        }
        canvas{
            max-width: 100%;
            max-height: 100%;
            display: block;
            margin: auto;
        }
        i{color:#95bac7;}
        b{color:#fcba03;}
        label{padding:0em 1em;}
        input[type="number"]{color:#a0ffff;background:#020208;padding:0em 0.5em;}
    </style>
</head>
<body>
<script src="lib.js"></script>
<script src="common.js"></script>
<script src="mechanics.js"></script>
<script src="main.js"></script>
<script>
    const app = new Application()
    .register(Renderer, { width: 800, height: 600 })
    .register(Camera, { x: -200, y: -360 })
    .register(Pointer)
    .register(Keyboard)
    .register(class CameraController {
        update(context){
            const camera = context.fetch(Camera)
            const pointer = context.fetch(Pointer)
            const keys = context.fetch(Keyboard)

            if(pointer.pressed && pointer.trigger) this.start = {
                x: camera.x - pointer.position.x,
                y: camera.y - pointer.position.y
            }
            if(pointer.pressed){
                camera.x = this.start.x + pointer.position.x
                camera.y = this.start.y + pointer.position.y
            }
        }
    })
    .register(UserInterface = class UserInterface {
        constructor(context){
            this.root = DomElement('div', { style: { display: 'flex', flexDirection: 'column' } })
            const panel = DomElement('div', { style: { display: 'flex', flexDirection: 'row' } })
            this.root.appendChild(panel)

            this.buildings = DomElement('div', { style: { display: 'flex', flexDirection: 'column' } },
            buildings.map((building, index) => DomElement('button', { innerText: building.name, value: index })))
            panel.appendChild(this.buildings)

            this.buildings.addEventListener('click', event => {
                if(event.target.value == null) return
                //if(this.action) this.action.dom.style.removeProperty('background')
                this.action = { dom: event.target, type: 'build', payload: event.target.value }
                //this.action.dom.style.setProperty('background', '#8bcc56')
            })

            this.actions = DomElement('div', {
                style: { display: 'flex', flexDirection: 'column' },
                onclick: event => this.action = { dom: event.target, type: event.target.value }
            }, ['toggle','destroy','next'].map(action => DomElement('button', { innerText: action, value: action })))
            panel.appendChild(this.actions)

            this.summary = document.createElement('div')
            Object.assign(this.buildings.style, { display: 'flex', flexDirection: 'column' })
            panel.appendChild(this.summary)
            this.fields = ['cells','production','consumption','matter','stored'].reduce((map, label) => {
                const value = DomElement('input', { type: 'number', min: 0, max: 1e6, step: 1, disabled: true })
                const field = DomElement('div', { style: { display: 'flex', flexDirection: 'row' } }, [
                    DomElement('label', { innerText: label }), value
                ])
                this.summary.appendChild(field)
                return Object.assign(map, { [label]: value })
            }, {})

            panel.appendChild(this.selected = DomElement('div', { style: { display: 'flex', flexDirection: 'column' } }))
        }
        start(context){ document.body.appendChild(this.root) }
        update(context){}
        hover(cell, group, adjacent, index, network){
            for(let i = 0; i < buildings.length; i++)
                this.buildings.children[i].disabled = !buildings[i].validate(cell, index, network)

            const summary = network.adjacent(index).reduce((summary, group) => {
                for(let key in summary) summary[key] += group[key]
                return summary
            }, {
                cells: 0, production: 0, consumption: 0,
                matter: 0, stored: 0
            })
            for(let key in summary) this.fields[key].value = summary[key]
            this.selected.innerHTML = cell ? cell.toString() : ''
        }
    })
    .register(class Demo {
        static fixedTimeDelta = 0.2
        constructor(context){
            this.agent = 1
            this.elapsed = 0
            this.map = new HexGrid({ columns: 9, rows: 9, size: 36, flat: true })
            this.units = []
            this.reticle = new Reticle()
            this.network = new NetworkGroup(this.map, this.agent, this)
        }
        start(context){
            const Building = buildings.find(building => building.name === 'Portal')
            this.map.grid[this.map.index(6,6)] = Object.assign(new Building(), { frame: context.frame, agent: this.agent + 1 })
        }
        update(context){
            this.elapsed += 0.001 * context.deltaTime
            const renderer = context.fetch(Renderer)
            const camera = context.fetch(Camera)
            const ui = context.fetch(UserInterface)
            this.reticle.x = -camera.x
            this.reticle.y = -camera.y

            this.updateAI(context)
            for(; this.elapsed > Demo.fixedTimeDelta; this.elapsed-=Demo.fixedTimeDelta) this.network.update(this)

            this.map.cart2hex(this.reticle, this.map.cursor)
            const index = this.map.index(this.map.cursor.x, this.map.cursor.y)
            const cell = index == -1 ? undefined : this.map.grid[index]
            const adjacent = index == -1 ? [] : this.map.neighbors[index].map(index => this.map.grid[index]).filter(Boolean)
            const group = index == -1 ? [] : this.map.group(index, this.agent).map(index => this.map.grid[index])
            ui.hover(cell, group, adjacent, index, this.network)

            if(ui.action) switch(ui.action.type){
                case 'build': {
                    const Building = buildings[ui.action.payload]
                    this.map.grid[index] = Object.assign(new Building(), { frame: context.frame, agent: this.agent })
                    break
                }
                case 'toggle': {
                    if(!cell) break
                    if(cell.suspended) cell.suspended = null
                    else cell.suspended = {  }
                    cell.frame = context.frame
                    break
                }
                case 'destroy': {
                    if(!cell || cell.agent !== this.agent) break
                    this.map.grid[index] = null
                    break
                }
                case 'next': {
                    if(!cell || cell.agent === this.agent) break
                    cell.start()
                    break
                }
            }
            ui.action = null

            this.map.render(renderer.ctx)
            if(cell && cell._affected) for(let i of cell._affected){
                const center = this.map.hex2cart(this.map.coordinates[i], {x:0,y:0})
                this.map.renderHex(renderer.ctx, center.x, center.y)
                renderer.ctx.lineWidth = 2
                renderer.ctx.strokeStyle = '#00ffff'
                renderer.ctx.stroke()
            }
            if(cell && cell.renderUI){
                const center = this.map.hex2cart(this.map.coordinates[index], {x:0,y:0})
                cell.renderUI(renderer.ctx, center)
            }
            for(let unit of this.units) unit.render(renderer.ctx)
            this.reticle.render(renderer.ctx)
        }
        updateAI(context){
            for(let i = 0; i < this.map.grid.length; i++) if(this.map.grid[i] && this.map.grid[i].update){
                this.map.grid[i].update(i, this, context)
            }
            for(let i = this.units.length - 1; i >= 0; i--){
                const unit = this.units[i]
                if(unit.update(this, context) === false) this.units.splice(i, 1)
            }
        }
    })
    .run()
</script>
</body>
</html>